20.有效的括号
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

1.左括号必须用相同类型的右括号闭合。
2.左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。

示例 1:

输入: "()"
输出: true
示例 2:

输入: "()[]{}"
输出: true
示例 3:

输入: "(]"
输出: false
示例 4:

输入: "([)]"
输出: false
示例 5:

输入: "{[]}"
输出: true

class Solution {
    public boolean isValid(String s) {
        String[] arr=s.split("");
        Stack<String> stack = new Stack<>();
        int left=0;

        if(s.isEmpty())
            return true;
        if(arr.length%2==1)
            return false;
        if(arr[0].equals(")")||arr[0].equals("]")||arr[0].equals("}"))
            return false;
        for(int i=0;i<arr.length;i++)
        {
            if(arr[i].equals("(")||arr[i].equals("[")||arr[i].equals("{"))
            {
                stack.push(arr[i]);
                left+=1;
            }
            else if(arr[i].equals(")"))
            {
                left-=1;
                if(!stack.pop().equals("("))
                    return false;
            }
            else if(arr[i].equals("]"))
            {
                left-=1;
                if(!stack.pop().equals("["))
                    return false;
            }
            else if(arr[i].equals("}"))
            {
                left-=1;
                if(!stack.pop().equals("{"))
                    return false;
            }
        }
        if(left!=0)
            return false;
        return true;
    }
}
因为左右括号要进行匹配，所以这一题我们可以用到栈，遇到左括号进栈，遇到右括号则用pop方法查看栈顶是否是相匹配的左括号。
手动排除输入为空等特殊情况，通过了本题。

虽然大致上的思路没问题，但是这个解法实在是太笨以至于我自己都看不下去。因此参考官方解法：
class Solution {
  private HashMap<Character, Character> mappings;

  public Solution() {
    this.mappings = new HashMap<Character, Character>();
    this.mappings.put(')', '(');
    this.mappings.put('}', '{');
    this.mappings.put(']', '[');
  }

  public boolean isValid(String s) {

    Stack<Character> stack = new Stack<Character>();

    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);

      if (this.mappings.containsKey(c)) {

        char topElement = stack.empty() ? '#' : stack.pop();

        if (topElement != this.mappings.get(c)) {
          return false;
        }
      } else {
        stack.push(c);
      }
    }
    return stack.isEmpty();
  }
}
官方解法用了哈希表来匹配左右括号。对比来看，我对于各种数据基本类型操作方法的使用还不够熟练。

另外还发现了一位大神使用字典的python解法，十分简单明了：
class Solution:
    def isValid(self, s: str) -> bool:
        dic = {'{': '}',  '[': ']', '(': ')', '?': '?'}
        stack = ['?']
        for c in s:
            if c in dic: stack.append(c)
            elif dic[stack.pop()] != c: return False 
        return len(stack) == 1
对应的Java代码：
class Solution {
    private static final Map<Character,Character> map = new HashMap<Character,Character>(){{
        put('{','}'); put('[',']'); put('(',')'); put('?','?');
    }};
    public boolean isValid(String s) {
        if(s.length() > 0 && !map.containsKey(s.charAt(0))) return false;
        LinkedList<Character> stack = new LinkedList<Character>() {{ add('?'); }};
        for(Character c : s.toCharArray()){
            if(map.containsKey(c)) stack.addLast(c);
            else if(map.get(stack.removeLast()) != c) return false;
        }
        return stack.size() == 1;
    }
}